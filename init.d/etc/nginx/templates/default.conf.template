# fss-proxy default config (by @allex_wang)
upstream backend.srv {
  {{ $servers := split .FSS_UPSTREAM "," }}{{ range $servers }}
  {{ if . }}server {{.}};{{ end }}
  {{ end }}
}

server {
  {{ $bind_sock := printf "unix:/tmp/fss-proxy-%s.sock" uuid }}
  {{if .FSS_SERVER_NAME}}server_name $FSS_SERVER_NAME;{{end}}

  listen {{$bind_sock}};
  listen {{.FSS_PORT}};

  {{if .FSS_SSL_PORT}}
  listen {{.FSS_SSL_PORT}} ssl;
  http2 on;
  ssl_certificate ssl/tls.crt;
  ssl_certificate_key ssl/tls.key;
  error_page 497 =301 https://$http_host$request_uri;
  {{end}}

  {{if is_true .FSS_FORCE_SSL}}
  if ($x_forwarded_proto != "https") {
    return 301 https://$host:${FSS_SSL_PORT:-443}$request_uri;
  }
  {{end}}

  charset UTF-8;
  root /var/www;
  index index.html;

  {{if is_true .FSS_FIX_HTTPS_COOKIE}}
  # patch backend cookie samesite flags
  set $cookie_samesite_conditions "";
  if ( $http_user_agent ~ "Chrome[^ \/]*\/[189][\d]+[\.\d]*" ) { set $cookie_samesite_conditions "${x_forwarded_proto}_Chrome_Adv"; }
  {{end}}

  {{if .FSS_VALID_REFERERS}}
  # > build valid_referers
  valid_referers {{.FSS_VALID_REFERERS}};
  if ($invalid_referer) {
    return 403;
  }
  {{end}}

  {{ $with_context_path := and .FSS_CONTEXT_PATH (ne .FSS_CONTEXT_PATH "/") }}

  {{if $with_context_path}}
  set $context_path "{{rtrim .FSS_CONTEXT_PATH "/"}}";
  location ${FSS_CONTEXT_PATH} {
    access_log off;
    include "proxy_set.conf";
    proxy_set_header X-Internal-Proxy "1";
    proxy_pass http://{{$bind_sock}}:/;
  }
  {{end}}

  location / {
    {{if $with_context_path}}
    # Redirect direct external access to context path when configured
    # Allow internal proxy requests (with X-Internal-Proxy header)
    if ($http_x_internal_proxy != "1") { return 301 $context_path$request_uri; }
    {{end}}

    if (-f $request_filename) { break; }
    {{if is_true .FSS_SPA}}try_files $uri $uri/ $resource_path;
    {{else}}try_files $uri $uri/;{{end}}

    expires 30s;
    add_header X-Origin-Server $hostname;
    {{if .FSS_HEADERS_CSP}}add_header Content-Security-Policy "{{.FSS_HEADERS_CSP}}";{{end}}
    {{if .FSS_HEADERS_XSS_PROTECTION}}add_header X-XSS-Protection "{{.FSS_HEADERS_XSS_PROTECTION}}";{{end}}
    {{if .BUILD_VERSION}}add_header X-Build-Version "{{.BUILD_VERSION}}";{{end}}
    add_header Access-Control-Allow-Origin "*";
    add_header Access-Control-Allow-Methods "POST, GET, OPTIONS";
    add_header X-Content-Type-Options nosniff;

    location ~* \.(js|css|eot|woff|woff2|ttf|svg|gif|jpeg|jpg|png|bmp|webp|swf|ico|mp4|ogg|ogv|ogm|webm)(\?|$) {
      {{if $with_context_path}}
      if ($http_x_internal_proxy != "1") { return 301 $context_path$request_uri; }
      {{end}}
      expires 30d;
      include static_header_set.conf;
      {{if .BUILD_VERSION}}add_header X-Build-Version "{{.BUILD_VERSION}}";{{end}}
    }
  }

  # adapt set proxy_connection for http/websock
  set $proxy_connection "close";
  if ($http_upgrade = "websocket") {
     set $proxy_connection "upgrade";
  }

  {{if .FSS_PROXY}}
  # > generate proxy configs (start)
  {{range jsonparse .FSS_PROXY}}
  location ^~ {{.path}} {
    include "proxy_set.conf";
    {{if ne .rewrite false}}
    rewrite ^{{rtrim .path "/"}}/(?<rewrite_path>.+)$ /$1 break;
    {{end}}
    proxy_pass {{.target}};
    add_header X-Via "$upstream_addr";
    proxy_http_version 1.1;
    proxy_intercept_errors on;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $proxy_connection;
    {{if .cors}}
    add_header Access-Control-Allow-Origin "*";
    add_header Access-Control-Allow-Methods "POST, GET, OPTIONS";
    {{end}}
  }
  {{end}}
  # > generate proxy configs (end)
  {{end}}

  {{if .FSS_API_BASE}}
  location ^~ {{.FSS_API_BASE}} { try_files $uri @$http_upgrade; }
  {{end}}

  {{if .FSS_SVC_PREFIX}}
  location ^~ {{.FSS_SVC_PREFIX}} { try_files $uri @$http_upgrade; }
  {{end}}

  location @websocket {
    rewrite ^.*$ $api_rewrite_url break;
    proxy_pass http://backend.srv;
    proxy_http_version 1.1;
    proxy_set_header Connection "Upgrade";
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    add_header X-Via "$upstream_addr";
  }
  location @ {
    access_log /var/log/nginx/access.log upstream;
    include "proxy_set.conf";
    rewrite ^/(?<p>[^/]+)/.*$ $api_rewrite_url break;
    proxy_pass http://backend.srv;
    proxy_redirect ~^http://(backend.srv|localhost)/(.*) http://$http_host/${p}/$2;
    proxy_intercept_errors on;
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    add_header X-Via "$upstream_addr";
    {{if is_true .FSS_FIX_HTTPS_COOKIE}}proxy_cookie_path / /$x_proxy_cookie_flags;{{end}}
    add_header Content-Type $api_content_type;
  }
}

{{if is_true .FSS_FIX_HTTPS_COOKIE}}
map $cookie_samesite_conditions $x_proxy_cookie_flags {
  default             "";
  "https_Chrome_Adv"  "; SameSite=None; Secure";
}
{{end}}

map $uri $api_rewrite_url {
  default $uri;
  {{if is_true .FSS_REWRITE_API}}
  ~^{{.FSS_API_BASE}}(.*) /$1;
  {{else}}
  ~^{{.FSS_API_BASE}}.* $uri;
  {{end}}
}

map $uri $api_content_type {
  ~\.png$ image/png;
  ~\.(jpg|jpeg)$ image/jpeg;
  ~\.(svg|svgz)$ image/svg+xml;
}
